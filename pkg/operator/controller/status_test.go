package controller

import (
	"fmt"
	"testing"
	configv1 "github.com/openshift/api/config/v1"
	operatorv1 "github.com/openshift/api/operator/v1"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func TestComputeStatusConditions(t *testing.T) {
	_logClusterCodePath()
	defer _logClusterCodePath()
	_logClusterCodePath()
	defer _logClusterCodePath()
	type testInputs struct {
		haveNamespace				bool
		numWanted, numAvailable, numUnavailable	int
	}
	type testOutputs struct{ failing, progressing, available bool }
	testCases := []struct {
		description	string
		inputs		testInputs
		outputs		testOutputs
	}{{"no namespace", testInputs{false, 0, 0, 0}, testOutputs{true, false, true}}, {"no dnses, no daemonsets", testInputs{true, 0, 0, 0}, testOutputs{false, false, true}}, {"scaling up", testInputs{true, 1, 0, 0}, testOutputs{false, true, false}}, {"scaling down", testInputs{true, 0, 1, 0}, testOutputs{false, true, true}}, {"0/2 daemonsets available", testInputs{true, 2, 0, 2}, testOutputs{false, false, false}}, {"1/2 daemonsets available", testInputs{true, 2, 1, 1}, testOutputs{false, false, false}}, {"2/2 daemonsets available", testInputs{true, 2, 2, 0}, testOutputs{false, false, true}}}
	for _, tc := range testCases {
		var (
			namespace			*corev1.Namespace
			dnses				[]operatorv1.DNS
			daemonsets			[]appsv1.DaemonSet
			failing, progressing, available	configv1.ConditionStatus
		)
		if tc.inputs.haveNamespace {
			namespace = &corev1.Namespace{}
		}
		for i := 0; i < tc.inputs.numWanted; i++ {
			dnses = append(dnses, operatorv1.DNS{ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("%d", i+1)}})
		}
		numDaemonsets := tc.inputs.numAvailable + tc.inputs.numUnavailable
		for i := 0; i < numDaemonsets; i++ {
			numberAvailable := 0
			if i < tc.inputs.numAvailable {
				numberAvailable = 1
			}
			daemonsets = append(daemonsets, appsv1.DaemonSet{ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("dns-%d", i+1)}, Status: appsv1.DaemonSetStatus{NumberAvailable: int32(numberAvailable)}})
		}
		if tc.outputs.failing {
			failing = configv1.ConditionTrue
		} else {
			failing = configv1.ConditionFalse
		}
		if tc.outputs.progressing {
			progressing = configv1.ConditionTrue
		} else {
			progressing = configv1.ConditionFalse
		}
		if tc.outputs.available {
			available = configv1.ConditionTrue
		} else {
			available = configv1.ConditionFalse
		}
		expected := []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorFailing, Status: failing}, {Type: configv1.OperatorProgressing, Status: progressing}, {Type: configv1.OperatorAvailable, Status: available}}
		new := computeStatusConditions([]configv1.ClusterOperatorStatusCondition{}, namespace, dnses, daemonsets)
		gotExpected := true
		if len(new) != len(expected) {
			gotExpected = false
		}
		for _, conditionA := range new {
			foundMatchingCondition := false
			for _, conditionB := range expected {
				if conditionA.Type == conditionB.Type && conditionA.Status == conditionB.Status {
					foundMatchingCondition = true
					break
				}
			}
			if !foundMatchingCondition {
				gotExpected = false
			}
		}
		if !gotExpected {
			t.Fatalf("%q: expected %#v, got %#v", tc.description, expected, new)
		}
	}
}
func TestSetStatusCondition(t *testing.T) {
	_logClusterCodePath()
	defer _logClusterCodePath()
	_logClusterCodePath()
	defer _logClusterCodePath()
	testCases := []struct {
		description	string
		oldConditions	[]configv1.ClusterOperatorStatusCondition
		newCondition	*configv1.ClusterOperatorStatusCondition
		expected	[]configv1.ClusterOperatorStatusCondition
	}{{description: "new condition", newCondition: &configv1.ClusterOperatorStatusCondition{Type: configv1.OperatorAvailable, Status: configv1.ConditionTrue}, expected: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable, Status: configv1.ConditionTrue}}}, {description: "existing condition, unchanged", oldConditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable, Status: configv1.ConditionTrue}}, newCondition: &configv1.ClusterOperatorStatusCondition{Type: configv1.OperatorAvailable, Status: configv1.ConditionTrue}, expected: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable, Status: configv1.ConditionTrue}}}, {description: "existing conditions, one changed", oldConditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorFailing, Status: configv1.ConditionFalse}, {Type: configv1.OperatorProgressing, Status: configv1.ConditionFalse}, {Type: configv1.OperatorAvailable, Status: configv1.ConditionFalse}}, newCondition: &configv1.ClusterOperatorStatusCondition{Type: configv1.OperatorAvailable, Status: configv1.ConditionTrue}, expected: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorFailing, Status: configv1.ConditionFalse}, {Type: configv1.OperatorProgressing, Status: configv1.ConditionFalse}, {Type: configv1.OperatorAvailable, Status: configv1.ConditionTrue}}}}
	for _, tc := range testCases {
		actual := setStatusCondition(tc.oldConditions, tc.newCondition)
		a := configv1.ClusterOperatorStatus{Conditions: actual}
		b := configv1.ClusterOperatorStatus{Conditions: tc.expected}
		if !statusesEqual(a, b) {
			t.Fatalf("%q: expected %v, got %v", tc.description, tc.expected, actual)
		}
	}
}
func TestStatusesEqual(t *testing.T) {
	_logClusterCodePath()
	defer _logClusterCodePath()
	_logClusterCodePath()
	defer _logClusterCodePath()
	testCases := []struct {
		description	string
		expected	bool
		a, b		configv1.ClusterOperatorStatus
	}{{description: "zero-valued ClusterOperatorStatus should be equal", expected: true}, {description: "nil and non-nil slices are equal", expected: true, a: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{}}}, {description: "empty slices should be equal", expected: true, a: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{}}, b: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{}}}, {description: "check no change in versions", expected: true, a: configv1.ClusterOperatorStatus{Versions: []configv1.OperandVersion{{Name: "operator", Version: "v1"}, {Name: "coredns", Version: "v2"}}}, b: configv1.ClusterOperatorStatus{Versions: []configv1.OperandVersion{{Name: "operator", Version: "v1"}, {Name: "coredns", Version: "v2"}}}}, {description: "condition LastTransitionTime should be ignored", expected: true, a: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable, Status: configv1.ConditionTrue, LastTransitionTime: metav1.Unix(0, 0)}}}, b: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable, Status: configv1.ConditionTrue, LastTransitionTime: metav1.Unix(1, 0)}}}}, {description: "order of versions should not matter", expected: true, a: configv1.ClusterOperatorStatus{Versions: []configv1.OperandVersion{{Name: "operator", Version: "v1"}, {Name: "coredns", Version: "v2"}}}, b: configv1.ClusterOperatorStatus{Versions: []configv1.OperandVersion{{Name: "coredns", Version: "v2"}, {Name: "operator", Version: "v1"}}}}, {description: "check missing related objects", expected: false, a: configv1.ClusterOperatorStatus{RelatedObjects: []configv1.ObjectReference{{Name: "openshift-dns"}, {Name: "default"}}}, b: configv1.ClusterOperatorStatus{RelatedObjects: []configv1.ObjectReference{{Name: "default"}}}}, {description: "check extra related objects", expected: false, a: configv1.ClusterOperatorStatus{RelatedObjects: []configv1.ObjectReference{{Name: "default"}}}, b: configv1.ClusterOperatorStatus{RelatedObjects: []configv1.ObjectReference{{Name: "openshift-dns"}, {Name: "default"}}}}, {description: "check condition reason differs", expected: false, a: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable, Status: configv1.ConditionFalse, Reason: "foo"}}}, b: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable, Status: configv1.ConditionFalse, Reason: "bar"}}}}, {description: "check duplicate with single condition", expected: false, a: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable, Message: "foo"}}}, b: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable, Message: "foo"}, {Type: configv1.OperatorAvailable, Message: "foo"}}}}, {description: "check duplicate with multiple conditions", expected: false, a: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorAvailable}, {Type: configv1.OperatorProgressing}, {Type: configv1.OperatorAvailable}}}, b: configv1.ClusterOperatorStatus{Conditions: []configv1.ClusterOperatorStatusCondition{{Type: configv1.OperatorProgressing}, {Type: configv1.OperatorAvailable}, {Type: configv1.OperatorProgressing}}}}}
	for _, tc := range testCases {
		if actual := statusesEqual(tc.a, tc.b); actual != tc.expected {
			t.Fatalf("%q: expected %v, got %v", tc.description, tc.expected, actual)
		}
	}
}
